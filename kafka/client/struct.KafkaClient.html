<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `KafkaClient` struct in crate `kafka`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, KafkaClient">

    <title>kafka::client::KafkaClient - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>kafka</a>::<wbr><a href='index.html'>client</a></p><script>window.sidebarCurrent = {name: 'KafkaClient', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='../index.html'>kafka</a>::<wbr><a href='index.html'>client</a>::<wbr><a class='struct' href=''>KafkaClient</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-942' class='srclink' href='../../src/kafka/src/client/mod.rs.html#85-94' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct KafkaClient {
    // some fields omitted
}</pre><div class='docblock'><p>Client struct keeping track of brokers and topic metadata.</p>

<p>Implements methods described by the <a href="http://kafka.apache.org/protocol.html">Kafka Protocol</a>.</p>

<p>You will have to load metadata before making any other request.</p>
</div><h2 id='methods'>Methods</h2><h3 class='impl'><span class='in-band'><code>impl <a class='struct' href='../../kafka/client/struct.KafkaClient.html' title='kafka::client::KafkaClient'>KafkaClient</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-1146' class='srclink' href='../../src/kafka/src/client/mod.rs.html#355-1170' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(hosts: <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>&gt;) -&gt; <a class='struct' href='../../kafka/client/struct.KafkaClient.html' title='kafka::client::KafkaClient'>KafkaClient</a></code></h4>
<div class='docblock'><p>Creates a new instance of KafkaClient. Before being able to
successfully use the new client, you&#39;ll have to load metadata.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()));
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();</pre>
</div><h4 id='method.new_secure' class='method'><code>fn <a href='#method.new_secure' class='fnname'>new_secure</a>(hosts: <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>&gt;, security: <a class='struct' href='../../kafka/client/struct.SecurityConfig.html' title='kafka::client::SecurityConfig'>SecurityConfig</a>) -&gt; <a class='struct' href='../../kafka/client/struct.KafkaClient.html' title='kafka::client::KafkaClient'>KafkaClient</a></code></h4>
<div class='docblock'><p>Creates a new secure instance of KafkaClient. Before being able to
successfully use the new client, you&#39;ll have to load metadata.</p>

<h1 id='examples-1' class='section-header'><a href='#examples-1'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>openssl</span>;
<span class='kw'>extern</span> <span class='kw'>crate</span> <span class='ident'>kafka</span>;

<span class='kw'>use</span> <span class='ident'>openssl</span>::<span class='ident'>ssl</span>::{<span class='ident'>SslContext</span>, <span class='ident'>SslMethod</span>, <span class='ident'>SSL_VERIFY_PEER</span>};
<span class='kw'>use</span> <span class='ident'>openssl</span>::<span class='ident'>x509</span>::<span class='ident'>X509FileType</span>;
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>SecurityConfig</span>};

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> (<span class='ident'>key</span>, <span class='ident'>cert</span>) <span class='op'>=</span> (<span class='string'>&quot;client.key&quot;</span>.<span class='ident'>to_string</span>(), <span class='string'>&quot;client.crt&quot;</span>.<span class='ident'>to_string</span>());

    <span class='comment'>// OpenSSL offers a variety of complex configurations. Here is an example:</span>
    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>ctx</span> <span class='op'>=</span> <span class='ident'>SslContext</span>::<span class='ident'>new</span>(<span class='ident'>SslMethod</span>::<span class='ident'>Sslv23</span>).<span class='ident'>unwrap</span>();
    <span class='ident'>ctx</span>.<span class='ident'>set_cipher_list</span>(<span class='string'>&quot;DEFAULT&quot;</span>).<span class='ident'>unwrap</span>();
    <span class='ident'>ctx</span>.<span class='ident'>set_certificate_file</span>(<span class='kw-2'>&amp;</span><span class='ident'>cert</span>, <span class='ident'>X509FileType</span>::<span class='ident'>PEM</span>).<span class='ident'>unwrap</span>();
    <span class='ident'>ctx</span>.<span class='ident'>set_private_key_file</span>(<span class='kw-2'>&amp;</span><span class='ident'>key</span>, <span class='ident'>X509FileType</span>::<span class='ident'>PEM</span>).<span class='ident'>unwrap</span>();
    <span class='ident'>ctx</span>.<span class='ident'>set_default_verify_paths</span>().<span class='ident'>unwrap</span>();
    <span class='ident'>ctx</span>.<span class='ident'>set_verify</span>(<span class='ident'>SSL_VERIFY_PEER</span>);

    <span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new_secure</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()),
                                             <span class='ident'>SecurityConfig</span>::<span class='ident'>new</span>(<span class='ident'>ctx</span>));
    <span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
}</pre>

<p>See also <code>KafkaClient::load_metadatata_all</code> and
<code>KafkaClient::load_metadata</code> methods, the creates
<a href="https://crates.io/crates/openssl">openssl</a>
and <a href="https://crates.io/crates/openssl-verify">openssl_verify</a>,
as well as
<a href="https://kafka.apache.org/documentation.html#security_ssl">Kafka&#39;s documentation</a>.</p>
</div><h4 id='method.hosts' class='method'><code>fn <a href='#method.hosts' class='fnname'>hosts</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a><a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a><a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a></code></h4>
<div class='docblock'><p>Exposes the hosts used for discovery of the target kafka
cluster.  This set of hosts corresponds to the values supplied
to <code>KafkaClient::new</code>.</p>
</div><h4 id='method.set_compression' class='method'><code>fn <a href='#method.set_compression' class='fnname'>set_compression</a>(&amp;mut self, compression: <a class='enum' href='../../kafka/client/enum.Compression.html' title='kafka::client::Compression'>Compression</a>)</code></h4>
<div class='docblock'><p>Sets the compression algorithm to use when sending out messages.</p>

<h1 id='example' class='section-header'><a href='#example'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>Compression</span>, <span class='ident'>KafkaClient</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()));
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='ident'>client</span>.<span class='ident'>set_compression</span>(<span class='ident'>Compression</span>::<span class='ident'>NONE</span>);</pre>
</div><h4 id='method.compression' class='method'><code>fn <a href='#method.compression' class='fnname'>compression</a>(&amp;self) -&gt; <a class='enum' href='../../kafka/client/enum.Compression.html' title='kafka::client::Compression'>Compression</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_compression</code> setting.</p>
</div><h4 id='method.set_fetch_max_wait_time' class='method'><code>fn <a href='#method.set_fetch_max_wait_time' class='fnname'>set_fetch_max_wait_time</a>(&amp;mut self, max_wait_time: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Sets the maximum time in milliseconds to wait for insufficient
data to become available when fetching messages.</p>

<p>See also <code>KafkaClient::set_fetch_min_bytes(..)</code> and
<code>KafkaClient::set_fetch_max_bytes_per_partition(..)</code>.</p>
</div><h4 id='method.fetch_max_wait_time' class='method'><code>fn <a href='#method.fetch_max_wait_time' class='fnname'>fetch_max_wait_time</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_fetch_max_wait_time</code>
setting.</p>
</div><h4 id='method.set_fetch_min_bytes' class='method'><code>fn <a href='#method.set_fetch_min_bytes' class='fnname'>set_fetch_min_bytes</a>(&amp;mut self, min_bytes: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Sets the minimum number of bytes of available data to wait for
as long as specified by <code>KafkaClient::set_fetch_max_wait_time</code>
when fetching messages.</p>

<p>By setting higher values in combination with the timeout the
consumer can tune for throughput and trade a little additional
latency for reading only large chunks of data (e.g. setting
MaxWaitTime to 100 ms and setting MinBytes to 64k would allow
the server to wait up to 100ms to try to accumulate 64k of
data before responding).</p>

<h1 id='example-1' class='section-header'><a href='#example-1'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>FetchPartition</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='ident'>client</span>.<span class='ident'>set_fetch_max_wait_time</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>100</span>));
<span class='ident'>client</span>.<span class='ident'>set_fetch_min_bytes</span>(<span class='number'>64</span> <span class='op'>*</span> <span class='number'>1024</span>);
<span class='kw'>let</span> <span class='ident'>r</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>fetch_messages</span>(<span class='kw-2'>&amp;</span>[<span class='ident'>FetchPartition</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>0</span>, <span class='number'>0</span>)]);</pre>

<p>See also <code>KafkaClient::set_fetch_max_wait_time(..)</code> and
<code>KafkaClient::set_fetch_max_bytes_per_partition(..)</code>.</p>
</div><h4 id='method.fetch_min_bytes' class='method'><code>fn <a href='#method.fetch_min_bytes' class='fnname'>fetch_min_bytes</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_fetch_min_bytes</code>
setting.</p>
</div><h4 id='method.set_fetch_max_bytes_per_partition' class='method'><code>fn <a href='#method.set_fetch_max_bytes_per_partition' class='fnname'>set_fetch_max_bytes_per_partition</a>(&amp;mut self, max_bytes: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Sets the default maximum number of bytes to obtain from <em>a
single kafka partition</em> when fetching messages.</p>

<p>This basically determines the maximum message size this client
will be able to fetch.  If a topic partition contains a
message larger than this specified number of bytes, the server
will not deliver it.</p>

<p>Note that this setting is related to a single partition.  The
overall potential data size in a fetch messages response will
thus be determined by the number of partitions in the fetch
messages request times this &quot;max bytes per partitions.&quot;</p>

<p>This client will use this setting by default for all queried
partitions, however, <code>fetch_messages</code> does allow you to
override this setting for a particular partition being
queried.</p>

<p>See also <code>KafkaClient::set_fetch_max_wait_time</code>,
<code>KafkaClient::set_fetch_min_bytes</code>, and <code>KafkaClient::fetch_messages</code>.</p>
</div><h4 id='method.fetch_max_bytes_per_partition' class='method'><code>fn <a href='#method.fetch_max_bytes_per_partition' class='fnname'>fetch_max_bytes_per_partition</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>Retrieves the current
<code>KafkaClient::set_fetch_max_bytes_per_partition</code> setting.</p>
</div><h4 id='method.set_fetch_crc_validation' class='method'><code>fn <a href='#method.set_fetch_crc_validation' class='fnname'>set_fetch_crc_validation</a>(&amp;mut self, validate_crc: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Specifies whether the to perform CRC validation on fetched
messages.</p>

<p>This ensures detection of on-the-wire or on-disk corruption to
fetched messages.  This check adds some overhead, so it may be
disabled in cases seeking extreme performance.</p>
</div><h4 id='method.fetch_crc_validation' class='method'><code>fn <a href='#method.fetch_crc_validation' class='fnname'>fetch_crc_validation</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_fetch_crc_validation</code>
setting.</p>
</div><h4 id='method.set_group_offset_storage' class='method'><code>fn <a href='#method.set_group_offset_storage' class='fnname'>set_group_offset_storage</a>(&amp;mut self, storage: <a class='enum' href='../../kafka/client/enum.GroupOffsetStorage.html' title='kafka::client::GroupOffsetStorage'>GroupOffsetStorage</a>)</code></h4>
<div class='docblock'><p>Specifies the group offset storage to address when fetching or
committing group offsets.</p>

<p>In addition to Zookeeper, Kafka 0.8.2 brokers or later offer a
more performant (and scalable) way to manage group offset
directly by itself. Note that the remote storages are separate
and independent on each other. Hence, you typically want
consistently hard-code your choice in your program.</p>

<p>Unless you have a 0.8.1 broker or want to participate in a
group which is already based on Zookeeper, you generally want
to choose <code>GroupOffsetStorage::Kafka</code> here.</p>

<p>See also <code>KafkaClient::fetch_group_offsets</code> and
<code>KafkaClient::commit_offsets</code>.</p>
</div><h4 id='method.group_offset_storage' class='method'><code>fn <a href='#method.group_offset_storage' class='fnname'>group_offset_storage</a>(&amp;self) -&gt; <a class='enum' href='../../kafka/client/enum.GroupOffsetStorage.html' title='kafka::client::GroupOffsetStorage'>GroupOffsetStorage</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_group_offset_storage</code>
settings.</p>
</div><h4 id='method.set_retry_backoff_time' class='method'><code>fn <a href='#method.set_retry_backoff_time' class='fnname'>set_retry_backoff_time</a>(&amp;mut self, time: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>)</code></h4>
<div class='docblock'><p>Specifies the time to wait before retrying a failed,
repeatable operation against Kafka.  This avoids retrying such
operations in a tight loop.</p>
</div><h4 id='method.retry_backoff_time' class='method'><code>fn <a href='#method.retry_backoff_time' class='fnname'>retry_backoff_time</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_retry_backoff_time</code>
setting.</p>
</div><h4 id='method.set_retry_max_attempts' class='method'><code>fn <a href='#method.set_retry_max_attempts' class='fnname'>set_retry_max_attempts</a>(&amp;mut self, attempts: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>)</code></h4>
<div class='docblock'><p>Specifies the upper limit of retry attempts for failed,
repeatable operations against kafka.  This avoids retrying
them forever.</p>
</div><h4 id='method.retry_max_attempts' class='method'><code>fn <a href='#method.retry_max_attempts' class='fnname'>retry_max_attempts</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a></code></h4>
<div class='docblock'><p>Retrieves the current <code>KafkaClient::set_retry_max_attempts</code>
setting.</p>
</div><h4 id='method.set_connection_idle_timeout' class='method'><code>fn <a href='#method.set_connection_idle_timeout' class='fnname'>set_connection_idle_timeout</a>(&amp;mut self, timeout: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>)</code></h4>
<div class='docblock'><p>Specifies the timeout after which idle connections will
transparently be closed/re-established by <code>KafkaClient</code>.</p>

<p>To be effective this value must be smaller than the <a href="https://kafka.apache.org/documentation.html#brokerconfigs">remote
broker&#39;s <code>connections.max.idle.ms</code>
setting</a>.</p>
</div><h4 id='method.connection_idle_timeout' class='method'><code>fn <a href='#method.connection_idle_timeout' class='fnname'>connection_idle_timeout</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a></code></h4>
<div class='docblock'><p>Retrieves the current
<code>KafkaClient::set_connection_idle_timeout</code> setting.</p>
</div><h4 id='method.topics' class='method'><code>fn <a href='#method.topics' class='fnname'>topics</a>(&amp;self) -&gt; <a class='struct' href='../../kafka/client/metadata/struct.Topics.html' title='kafka::client::metadata::Topics'>Topics</a></code></h4>
<div class='docblock'><p>Provides a view onto the currently loaded metadata of known .</p>

<h1 id='examples-2' class='section-header'><a href='#examples-2'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>;
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>metadata</span>::<span class='ident'>Broker</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>for</span> <span class='ident'>topic</span> <span class='kw'>in</span> <span class='ident'>client</span>.<span class='ident'>topics</span>() {
  <span class='kw'>for</span> <span class='ident'>partition</span> <span class='kw'>in</span> <span class='ident'>topic</span>.<span class='ident'>partitions</span>() {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} #{} =&gt; {}&quot;</span>, <span class='ident'>topic</span>.<span class='ident'>name</span>(), <span class='ident'>partition</span>.<span class='ident'>id</span>(),
             <span class='ident'>partition</span>.<span class='ident'>leader</span>()
                      .<span class='ident'>map</span>(<span class='ident'>Broker</span>::<span class='ident'>host</span>)
                      .<span class='ident'>unwrap_or</span>(<span class='string'>&quot;no-leader!&quot;</span>));
  }
}</pre>
</div><h4 id='method.load_metadata_all' class='method'><code>fn <a href='#method.load_metadata_all' class='fnname'>load_metadata_all</a>(&amp;mut self) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Resets and loads metadata for all topics from the underlying
brokers.</p>

<h1 id='examples-3' class='section-header'><a href='#examples-3'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()));
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>for</span> <span class='ident'>topic</span> <span class='kw'>in</span> <span class='ident'>client</span>.<span class='ident'>topics</span>().<span class='ident'>names</span>() {
  <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;topic: {}&quot;</span>, <span class='ident'>topic</span>);
}</pre>

<p>Returns the metadata for all loaded topics underlying this
client.</p>
</div><h4 id='method.load_metadata' class='method'><code>fn <a href='#method.load_metadata' class='fnname'>load_metadata</a>&lt;T:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;&gt;(&amp;mut self, topics: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>T<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Reloads metadata for a list of supplied topics.</p>

<p>Note: if any of the specified topics does not exist yet on the
underlying brokers and these have the <a href="https://kafka.apache.org/documentation.html#configuration">configuration for &quot;auto
create topics&quot;
enabled</a>,
the remote kafka instance will create the yet missing topics
on the fly as a result of explicitely loading their metadata.
This is in contrast to other methods of this <code>KafkaClient</code>
which will silently filter out requests to
not-yet-loaded/not-yet-known topics and, thus, not cause
topics to be automatically created.</p>

<h1 id='examples-4' class='section-header'><a href='#examples-4'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()));
<span class='kw'>let</span> _ <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>load_metadata</span>(<span class='kw-2'>&amp;</span>[<span class='string'>&quot;my-topic&quot;</span>]).<span class='ident'>unwrap</span>();</pre>

<p>Returns the metadata for <em>all</em> loaded topics underlying this
client (this might be more topics than specified right to this
method call.)</p>
</div><h4 id='method.reset_metadata' class='method'><code>fn <a href='#method.reset_metadata' class='fnname'>reset_metadata</a>(&amp;mut self)</code></h4>
<div class='docblock'><p>Clears metadata stored in the client.  You must load metadata
after this call if you want to use the client.</p>
</div><h4 id='method.fetch_offsets' class='method'><code>fn <a href='#method.fetch_offsets' class='fnname'>fetch_offsets</a>&lt;T:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;&gt;(&amp;mut self, topics: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[</a>T<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>]</a>, offset: <a class='enum' href='../../kafka/client/enum.FetchOffset.html' title='kafka::client::FetchOffset'>FetchOffset</a>) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/std/collections/hash/map/struct.HashMap.html' title='std::collections::hash::map::HashMap'>HashMap</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/string/struct.String.html' title='collections::string::String'>String</a>,&nbsp;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/struct.PartitionOffset.html' title='kafka::client::PartitionOffset'>PartitionOffset</a>&gt;&gt;&gt;</code></h4>
<div class='docblock'><p>Fetch offsets for a list of topics</p>

<h1 id='examples-5' class='section-header'><a href='#examples-5'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>topics</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>String</span><span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>topics</span>().<span class='ident'>names</span>().<span class='ident'>map</span>(<span class='ident'>ToOwned</span>::<span class='ident'>to_owned</span>).<span class='ident'>collect</span>();
<span class='kw'>let</span> <span class='ident'>offsets</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>fetch_offsets</span>(<span class='kw-2'>&amp;</span><span class='ident'>topics</span>, <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>FetchOffset</span>::<span class='ident'>Latest</span>).<span class='ident'>unwrap</span>();</pre>

<p>Returns a mapping of topic name to <code>PartitionOffset</code>s for each
currently available partition of the corresponding topic.</p>
</div><h4 id='method.fetch_topic_offsets' class='method'><code>fn <a href='#method.fetch_topic_offsets' class='fnname'>fetch_topic_offsets</a>&lt;T:&nbsp;<a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>&gt;&gt;(&amp;mut self, topic: T, offset: <a class='enum' href='../../kafka/client/enum.FetchOffset.html' title='kafka::client::FetchOffset'>FetchOffset</a>) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/struct.PartitionOffset.html' title='kafka::client::PartitionOffset'>PartitionOffset</a>&gt;&gt;</code></h4>
<div class='docblock'><p>Fetch offset for a single topic.</p>

<h1 id='examples-6' class='section-header'><a href='#examples-6'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>FetchOffset</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>offsets</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>fetch_topic_offsets</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='ident'>FetchOffset</span>::<span class='ident'>Latest</span>).<span class='ident'>unwrap</span>();</pre>

<p>Returns a vector of the offset data for each available partition.
See also <code>KafkaClient::fetch_offsets</code>.</p>
</div><h4 id='method.fetch_messages' class='method'><code>fn <a href='#method.fetch_messages' class='fnname'>fetch_messages</a>&lt;'a,&nbsp;I,&nbsp;J&gt;(&amp;mut self, input: I) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/fetch/struct.Response.html' title='kafka::client::fetch::Response'>Response</a>&gt;&gt; <span class='where'>where J: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../../kafka/client/struct.FetchPartition.html' title='kafka::client::FetchPartition'>FetchPartition</a>&lt;'a&gt;&gt;, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/traits/trait.IntoIterator.html' title='core::iter::traits::IntoIterator'>IntoIterator</a>&lt;Item=J&gt;</span></code></h4>
<div class='docblock'><p>Fetch messages from Kafka (multiple topic, partitions).</p>

<p>It takes a vector specifying the topic partitions and their
offsets as of which to fetch messages.  Additionally, the
default &quot;max fetch size per partition&quot; can be explicitely
overriden if it is &quot;defined&quot; - this is, if <code>max_bytes</code> is
greater than zero.</p>

<p>The result is exposed in a raw, complicated manner but allows
for very efficient consumption possibilities. All of the data
available through the returned fetch responses is bound to
their lifetime as that data is merely a &quot;view&quot; into parts of
the response structs.  If you need to keep individual messages
for a longer time than the whole fetch responses, you&#39;ll need
to make a copy of the message data.</p>

<ul>
<li><p>This method transparently uncompresses messages (while Kafka
might sent them in compressed format.)</p></li>
<li><p>This method ensures to skip messages with a lower offset
than requested (while Kafka might for efficiency reasons sent
messages with a lower offset.)</p></li>
</ul>

<p>Note: before using this method consider using
<code>kafka::consumer::Consumer</code> instead which provides an easier
to use API for the regular use-case of fetching messesage from
Kafka.</p>

<h1 id='example-2' class='section-header'><a href='#example-2'>Example</a></h1>
<p>This example demonstrates iterating all fetched messages from
two topic partitions.  From one partition we allow Kafka to
deliver to us the default number bytes as defined by
<code>KafkaClient::set_fetch_max_bytes_per_partition</code>, from the
other partition we allow Kafka to deliver up to 1MiB of
messages.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>FetchPartition</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()));
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>reqs</span> <span class='op'>=</span> <span class='kw-2'>&amp;</span>[<span class='ident'>FetchPartition</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>0</span>, <span class='number'>0</span>),
             <span class='ident'>FetchPartition</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic-2&quot;</span>, <span class='number'>0</span>, <span class='number'>0</span>).<span class='ident'>with_max_bytes</span>(<span class='number'>1024</span><span class='op'>*</span><span class='number'>1024</span>)];
<span class='kw'>let</span> <span class='ident'>resps</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>fetch_messages</span>(<span class='ident'>reqs</span>).<span class='ident'>unwrap</span>();
<span class='kw'>for</span> <span class='ident'>resp</span> <span class='kw'>in</span> <span class='ident'>resps</span> {
  <span class='kw'>for</span> <span class='ident'>t</span> <span class='kw'>in</span> <span class='ident'>resp</span>.<span class='ident'>topics</span>() {
    <span class='kw'>for</span> <span class='ident'>p</span> <span class='kw'>in</span> <span class='ident'>t</span>.<span class='ident'>partitions</span>() {
      <span class='kw'>match</span> <span class='ident'>p</span>.<span class='ident'>data</span>() {
        <span class='kw-2'>&amp;</span><span class='prelude-val'>Err</span>(<span class='kw-2'>ref</span> <span class='ident'>e</span>) <span class='op'>=&gt;</span> {
          <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;partition error: {}:{}: {}&quot;</span>, <span class='ident'>t</span>.<span class='ident'>topic</span>(), <span class='ident'>p</span>.<span class='ident'>partition</span>(), <span class='ident'>e</span>)
        }
        <span class='kw-2'>&amp;</span><span class='prelude-val'>Ok</span>(<span class='kw-2'>ref</span> <span class='ident'>data</span>) <span class='op'>=&gt;</span> {
          <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;topic: {} / partition: {} / latest available message offset: {}&quot;</span>,
                   <span class='ident'>t</span>.<span class='ident'>topic</span>(), <span class='ident'>p</span>.<span class='ident'>partition</span>(), <span class='ident'>data</span>.<span class='ident'>highwatermark_offset</span>());
          <span class='kw'>for</span> <span class='ident'>msg</span> <span class='kw'>in</span> <span class='ident'>data</span>.<span class='ident'>messages</span>() {
            <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;topic: {} / partition: {} / message.offset: {} / message.len: {}&quot;</span>,
                     <span class='ident'>t</span>.<span class='ident'>topic</span>(), <span class='ident'>p</span>.<span class='ident'>partition</span>(), <span class='ident'>msg</span>.<span class='ident'>offset</span>, <span class='ident'>msg</span>.<span class='ident'>value</span>.<span class='ident'>len</span>());
          }
        }
      }
    }
  }
}</pre>

<p>See also <code>kafka::consumer</code>.
See also <code>KafkaClient::set_fetch_max_bytes_per_partition</code>.</p>
</div><h4 id='method.fetch_messages_for_partition' class='method'><code>fn <a href='#method.fetch_messages_for_partition' class='fnname'>fetch_messages_for_partition</a>&lt;'a&gt;(&amp;mut self, req: &amp;<a class='struct' href='../../kafka/client/struct.FetchPartition.html' title='kafka::client::FetchPartition'>FetchPartition</a>&lt;'a&gt;) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/fetch/struct.Response.html' title='kafka::client::fetch::Response'>Response</a>&gt;&gt;</code></h4>
<div class='docblock'><p>Fetch messages from a single kafka partition.</p>

<p>See <code>KafkaClient::fetch_messages</code>.</p>
</div><h4 id='method.produce_messages' class='method'><code>fn <a href='#method.produce_messages' class='fnname'>produce_messages</a>&lt;'a,&nbsp;'b,&nbsp;I,&nbsp;J&gt;(&amp;mut self, acks: <a class='enum' href='../../kafka/client/enum.RequiredAcks.html' title='kafka::client::RequiredAcks'>RequiredAcks</a>, ack_timeout: <a class='struct' href='https://doc.rust-lang.org/nightly/std/time/duration/struct.Duration.html' title='std::time::duration::Duration'>Duration</a>, messages: I) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/struct.TopicPartitionOffset.html' title='kafka::client::TopicPartitionOffset'>TopicPartitionOffset</a>&gt;&gt; <span class='where'>where J: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../../kafka/client/struct.ProduceMessage.html' title='kafka::client::ProduceMessage'>ProduceMessage</a>&lt;'a,&nbsp;'b&gt;&gt;, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/traits/trait.IntoIterator.html' title='core::iter::traits::IntoIterator'>IntoIterator</a>&lt;Item=J&gt;</span></code></h4>
<div class='docblock'><p>Send a message to Kafka</p>

<p><code>required_acks</code> - indicates how many acknowledgements the
servers should receive before responding to the request</p>

<p><code>ack_timeout</code> - provides a maximum time in milliseconds the
server can await the receipt of the number of acknowledgements
in <code>required_acks</code></p>

<p><code>input</code> - the set of <code>ProduceMessage</code>s to send</p>

<p>Note: Unlike the higher-level <code>Producer</code> API, this method will
<em>not</em> automatically determine the partition to deliver the
message to.  It will strictly try to send the message to the
specified partition.</p>

<p>Note: Trying to send messages to non-existing topics or
non-existing partitions will result in an error.</p>

<h1 id='example-3' class='section-header'><a href='#example-3'>Example</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>ProduceMessage</span>, <span class='ident'>RequiredAcks</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>(<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()));
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>req</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[<span class='ident'>ProduceMessage</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>0</span>, <span class='prelude-val'>None</span>, <span class='prelude-val'>Some</span>(<span class='string'>&quot;a&quot;</span>.<span class='ident'>as_bytes</span>())),
               <span class='ident'>ProduceMessage</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic-2&quot;</span>, <span class='number'>0</span>, <span class='prelude-val'>None</span>, <span class='prelude-val'>Some</span>(<span class='string'>&quot;b&quot;</span>.<span class='ident'>as_bytes</span>()))];
<span class='kw'>let</span> <span class='ident'>resp</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>produce_messages</span>(<span class='ident'>RequiredAcks</span>::<span class='ident'>One</span>, <span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>100</span>), <span class='ident'>req</span>);
<span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{:?}&quot;</span>, <span class='ident'>resp</span>);</pre>

<p>The return value will contain a vector of topic, partition,
offset and error if any OR error:Error.</p>
</div><h4 id='method.commit_offsets' class='method'><code>fn <a href='#method.commit_offsets' class='fnname'>commit_offsets</a>&lt;'a,&nbsp;J,&nbsp;I&gt;(&amp;mut self, group: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, offsets: I) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt; <span class='where'>where J: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../../kafka/client/struct.CommitOffset.html' title='kafka::client::CommitOffset'>CommitOffset</a>&lt;'a&gt;&gt;, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/traits/trait.IntoIterator.html' title='core::iter::traits::IntoIterator'>IntoIterator</a>&lt;Item=J&gt;</span></code></h4>
<div class='docblock'><p>Commit offset for a topic partitions on behalf of a consumer group.</p>

<h1 id='examples-7' class='section-header'><a href='#examples-7'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>CommitOffset</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='ident'>client</span>.<span class='ident'>commit_offsets</span>(<span class='string'>&quot;my-group&quot;</span>,
    <span class='kw-2'>&amp;</span>[<span class='ident'>CommitOffset</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>0</span>, <span class='number'>100</span>),
      <span class='ident'>CommitOffset</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>1</span>, <span class='number'>99</span>)])
   .<span class='ident'>unwrap</span>();</pre>

<p>In this example, we commit the offset 100 for the topic
partition &quot;my-topic:0&quot; and 99 for the topic partition
&quot;my-topic:1&quot;.  Once successfully committed, these can then be
retrieved using <code>fetch_group_offsets</code> even from another
process or at much later point in time to resume comusing the
topic partitions as of these offsets.</p>
</div><h4 id='method.commit_offset' class='method'><code>fn <a href='#method.commit_offset' class='fnname'>commit_offset</a>(&amp;mut self, group: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, topic: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, partition: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, offset: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i64.html'>i64</a>) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>&gt;</code></h4>
<div class='docblock'><p>Commit offset of a particular topic partition on behalf of a
consumer group.</p>

<h1 id='examples-8' class='section-header'><a href='#examples-8'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='ident'>client</span>.<span class='ident'>commit_offset</span>(<span class='string'>&quot;my-group&quot;</span>, <span class='string'>&quot;my-topic&quot;</span>, <span class='number'>0</span>, <span class='number'>100</span>).<span class='ident'>unwrap</span>();</pre>

<p>See also <code>KafkaClient::commit_offsets</code>.</p>
</div><h4 id='method.fetch_group_offsets' class='method'><code>fn <a href='#method.fetch_group_offsets' class='fnname'>fetch_group_offsets</a>&lt;'a,&nbsp;J,&nbsp;I&gt;(&amp;mut self, group: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, partitions: I) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/struct.TopicPartitionOffset.html' title='kafka::client::TopicPartitionOffset'>TopicPartitionOffset</a>&gt;&gt; <span class='where'>where J: <a class='trait' href='https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html' title='core::convert::AsRef'>AsRef</a>&lt;<a class='struct' href='../../kafka/client/struct.FetchGroupOffset.html' title='kafka::client::FetchGroupOffset'>FetchGroupOffset</a>&lt;'a&gt;&gt;, I: <a class='trait' href='https://doc.rust-lang.org/nightly/core/iter/traits/trait.IntoIterator.html' title='core::iter::traits::IntoIterator'>IntoIterator</a>&lt;Item=J&gt;</span></code></h4>
<div class='docblock'><p>Fetch offset for a specified list of topic partitions of a consumer group</p>

<h1 id='examples-9' class='section-header'><a href='#examples-9'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::{<span class='ident'>KafkaClient</span>, <span class='ident'>FetchGroupOffset</span>};

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();

<span class='kw'>let</span> <span class='ident'>offsets</span> <span class='op'>=</span>
     <span class='ident'>client</span>.<span class='ident'>fetch_group_offsets</span>(<span class='string'>&quot;my-group&quot;</span>,
            <span class='kw-2'>&amp;</span>[<span class='ident'>FetchGroupOffset</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>0</span>),
              <span class='ident'>FetchGroupOffset</span>::<span class='ident'>new</span>(<span class='string'>&quot;my-topic&quot;</span>, <span class='number'>1</span>)])
            .<span class='ident'>unwrap</span>();</pre>

<p>See also <code>KafkaClient::fetch_group_topic_offsets</code>.</p>
</div><h4 id='method.fetch_group_topic_offsets' class='method'><code>fn <a href='#method.fetch_group_topic_offsets' class='fnname'>fetch_group_topic_offsets</a>(&amp;mut self, group: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>, topic: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>) -&gt; <a class='type' href='../../kafka/error/type.Result.html' title='kafka::error::Result'>Result</a>&lt;<a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='struct' href='../../kafka/client/struct.TopicPartitionOffset.html' title='kafka::client::TopicPartitionOffset'>TopicPartitionOffset</a>&gt;&gt;</code></h4>
<div class='docblock'><p>Fetch offset for all partitions of a particular topic of a consumer group</p>

<h1 id='examples-10' class='section-header'><a href='#examples-10'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>kafka</span>::<span class='ident'>client</span>::<span class='ident'>KafkaClient</span>;

<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>client</span> <span class='op'>=</span> <span class='ident'>KafkaClient</span>::<span class='ident'>new</span>(<span class='macro'>vec</span><span class='macro'>!</span>[<span class='string'>&quot;localhost:9092&quot;</span>.<span class='ident'>to_owned</span>()]);
<span class='ident'>client</span>.<span class='ident'>load_metadata_all</span>().<span class='ident'>unwrap</span>();
<span class='kw'>let</span> <span class='ident'>offsets</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>fetch_group_topic_offsets</span>(<span class='string'>&quot;my-group&quot;</span>, <span class='string'>&quot;my-topic&quot;</span>).<span class='ident'>unwrap</span>();</pre>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><span class='in-band'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../../kafka/client/struct.KafkaClient.html' title='kafka::client::KafkaClient'>KafkaClient</a></code></span><span class='out-of-band'><div class='ghost'></div><a id='src-934' class='srclink' href='../../src/kafka/src/client/mod.rs.html#84' title='goto source code'>[src]</a></span></h3>
<div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
<div class='docblock'><p>Formats the value using the given formatter.</p>
</div></div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "kafka";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>